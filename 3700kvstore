#!/usr/bin/env python

import sys, socket, select, time, json, random, math

# Your ID number
my_id = sys.argv[1]

# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(my_id)

num_total = len(replica_ids) + 1
last = 0
last_other = 0
past_beats = []
election_timeout = False
current_term = 0
leader = False
candidate = False
votes = 0
majority = math.ceil(num_total / 2) + 1

print("num total" + str(num_total))
print("majority" + str(majority))

current_leader = ""
voting_hist = []

votes_sent = 0

log = {}
reach_majority = False
log_index = []

def send_append_entry(msg):
	if len(log_index) == 0:
		prev_str = ""
	else:
		prev_str = [-1]

	send_to_all_msg = {"src": my_id, "dst": "FFFF",
				  "leader": my_id, "type": "append_entry",
				  "key": msg['key'], "value": msg['value'], "term": current_term,
					   "prev": prev_str}
	json_msg = json.dumps(send_to_all_msg)
	sock.send(json_msg.encode())

def break_down_str(str):
	#index_term_key_value
	prev = str.split(" ")
	return int(prev[0]), prev[1], prev[2], prev[3]

while True:
	ready = select.select([sock], [], [], 0.1)[0]

	if votes >= majority and candidate:
		print("got enough votes")
		current_leader = my_id
		leader = True
		candidate = False

	if sock in ready:
		msg_raw = sock.recv(32768)

		if len(msg_raw) == 0: continue
		msg = json.loads(msg_raw)

		# received heartbeat
		# heartbeat is from the new leader, stop candidacy
		if msg['type'] == "heartbeat":
			past_beats.append(1)
			current_leader = msg['src']
			candidate = False

		# if you get a request vote, vote for them if you have not yet voted in this term
		if msg['type'] == "RequestVote":
			if votes_sent < msg['term']:
				return_msg = {"src": my_id, "dst": msg['src'],
							  "leader": "FFFF", "type": "vote"}
				return_msg_json = json.dumps(return_msg)
				sock.send(return_msg_json.encode())
				votes_sent += 1

		# append_entry from leader, append to own and send back OK
		if msg['type'] == 'append_entry':
			# index_term_key_value
			index, term, key, value = break_down_str(msg["prev"])

			# if the previous log entry matches up...
			if (len(log_index) == 0 and msg['prev'] == "") or log_index[index] == term + " " + key + " " + value:
				# add to end of log as "term key value"
				log_index.append(msg['term'] + " " + msg['key'] + " " + msg['value'])
				log[msg['key']] = msg['value']

				return_msg = {"src": my_id, "dst": msg['src'],
							  "leader": msg['src'], "type": "ok"}
				return_msg_json = json.dumps(return_msg)
				sock.send(return_msg_json.encode())

		# if you get a vote, keep track
		if msg['type'] == "vote" and candidate:
			votes += 1

		# if you get a put message
		if msg['type'] == 'put':
			# if there is no current leader, fail and make client retry until leader is found
			if current_leader == "":
				return_msg = {"src": my_id, "dst": msg['src'],
							  "leader": msg['leader'], "type": "fail",
							  "MID": msg['MID']}
			# redirect to leader
			elif not leader:
				return_msg = {"src": my_id, "dst": msg['src'],
							  "leader": current_leader, "type": "redirect",
							  "MID": msg['MID']}
			# you are leader, append to own log and send out to replicas
			else:
				# put into own log
				log[msg['key']] = msg['value']

				# send out append entries
				send_append_entry(msg)
				return_msg = {"src": my_id, "dst": msg['src'],
							  "leader": my_id, "type": "ok",
							  "MID": msg['MID']}
			return_msg_json = json.dumps(return_msg)
			sock.send(return_msg_json.encode())

		# get message from client
		if msg['type'] == 'get':
			# if no current leader, make client retry
			if current_leader == "":
				return_msg = {"src": my_id, "dst": msg['src'],
							  "leader": msg['leader'], "type": "fail",
							  "MID": msg['MID']}
			# redirect to leader
			elif not leader:
				return_msg = {"src": my_id, "dst": msg['src'],
							  "leader": current_leader, "type": "redirect",
							  "MID": msg['MID']}
			# if leader, get the value and send back
			else:
				value = log.get(msg['key'], "")
				return_msg = {"src": my_id, "dst": msg['src'],
							  "leader": my_id, "type": "ok", "MID": msg['MID'], "value": value}
			return_msg_json = json.dumps(return_msg)
			sock.send(return_msg_json.encode())


	clock = time.time()
	second_clock = time.time()

	# code runs every 2 seconds
	if clock - last > 2 and leader:
		# send heartbeat
		msg = {'src': my_id, 'dst': "FFFF", 'leader': my_id,
			   'type': 'heartbeat', "term": current_term}
		print("sent heartbeat")
		sock.send(json.dumps(msg).encode())
		last = clock

	# if have not received a heart beat... (empty list)
	if second_clock - last_other > random.randint(4,8) and not leader:
		# if no heartbeats received.. then begin election timeout
		if len(past_beats) == 0:
			election_timeout = True
		else:
			past_beats = []
		last_other = second_clock

	if election_timeout:
		# transition to candidate
		candidate = True

		# majority is -1 given the leader failed
		majority -= current_term

		# increment the current term
		current_term += 1

		# vote for yourself
		votes = 1

		# request votes from others
		msg = {'src': my_id, 'dst': "FFFF", 'leader': "FFFF", 'type': 'RequestVote', "term": current_term}
		sock.send(json.dumps(msg).encode())
		print("requesting votes")
		election_timeout = False
