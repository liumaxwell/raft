#!/usr/bin/env python

import sys, socket, select, time, json, random, math

# Your ID number
my_id = sys.argv[1]

# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(my_id)

time.sleep(random.uniform(.5, 1.5))

num_total = len(replica_ids) + 1
last = 0
last_other = 0
past_beats = []
election_timeout = False
current_term = 0
leader = False
candidate = False
votes = 0
election_time = 0
majority = math.ceil(num_total / 2) + 1
leader_ready = False
no_op_index = 0
append_clock = 0
cache = []
catchup_state = False
get_index = 0
# r = random.randint(4, 8)
messages = {"puts": [], "gets": []}
voted = False
last_catchup = False

first_append_entry = 0

most_recent_leader = "FFFF"
voting_hist = {}

log = []
kvstore = {}

commit_index = -1
applied_index = -1

next_index = {}
match_index = {}

for the_id in replica_ids:
	next_index[the_id] = 0
	match_index[the_id] = -1
	# messages["appends"][the_id] = []
append_oks = 0

def make_follower():
	global leader_ready
	global leader
	global candidate
	global cache
	cache = []
	votes = 0
	leader_ready = False
	leader = False
	candidate = False

def print_log(typ):
	i = 0
	#print("START %s %s LOG ----------" % (typ, my_id))
	for entry in log:
		the_key = ""
		for key in list(entry.keys()):
			if key != 'term' and key != 'client_ID' and key != 'MID':
				the_key = key
		#print("%d. TERM: %d, KEY: %s, VALUE: %s, MID: %s" % (i, entry["term"], the_key, entry[the_key], entry["MID"]))
		i += 1
	#print("END %s %s LOG ----------" % (typ, my_id))

def up_to_date(msg):
	if msg['term'] > current_term:
		return True
	elif msg['term'] == current_term:
		return msg['index'] >= len(log) - 1
	else:
		return False

def send_heartbeat():
	msg = {"src": my_id, "dst": "FFFF", "leader": my_id, "type": "append_entry", 
	"entries": [], "lead_commit_index": commit_index, "term": current_term}
	sock.send(json.dumps(msg).encode())

def send_append_entry(dst):
	if dst:
		ids = [dst]
	else:
		ids = replica_ids
	for the_id in ids:
		rep_next_index = next_index[the_id]
		num_entries = min(50, len(log) - rep_next_index)
		entries = []
		for i in range(num_entries):
			if rep_next_index + i - 1 == -1:
				term = 1
			else:
				term = log[rep_next_index + i - 1]["term"]
			entry = log[rep_next_index + i]
			for key in list(entry.keys()):
				if key != 'term' and key != 'client_ID' and key != 'MID':
					the_key = key
			new_entry = {"key": the_key, "value": entry[the_key],
			"prev_index": rep_next_index + i - 1, "prev_term": term,
			"client_ID": entry['client_ID'], "MID": entry["MID"], "term": entry["term"]}
			entries.append(new_entry)
		msg = {"src": my_id, "dst": the_id, "leader": my_id, "term": current_term,
		"type": "append_entry", "entries": entries, "lead_commit_index": commit_index}
		if entries:
			sock.send(json.dumps(msg).encode())
		# messages["appends"][str(the_id)].append(new_msg)

# def send_to_follower(dst, msg):
# 	index = next_index[dst]
# 	the_key = ""
# 	if index == 0:
# 		prev_term = 1
# 	else:
# 		prev_term = log[index - 1]['term']
# 		term = current_term

# 	for key in list(log[index].keys()):
# 		if key != 'term' and key != 'client_ID' and key != 'MID':
# 			the_key = key

# 	new_msg = {"src": my_id, "dst": dst,
# 		   "leader": my_id, "type": "append_entry",
# 		   "key": the_key, "value": log[index][the_key],
# 		   "term": current_term, "prev_index": index - 1,
# 		   "prev_term": prev_term, "lead_commit_index": commit_index,
# 		   "client_ID": msg['client_ID'], "MID": msg["MID"], "time": time.time()}
# 	json_msg = json.dumps(new_msg)
# 	sock.send(json_msg.encode())
# 	messages["appends"][str(dst)].append(new_msg)

def reply_false(msg):
	return_msg = {"src": my_id, "dst": msg['src'], "leader": msg["src"],
	"type": "append_fail", "term": current_term}
	return_msg_json = json.dumps(return_msg)
	sock.send(return_msg_json.encode())

def reply_true(msg):
	return_msg = {"src": my_id, "dst": msg['src'], "leader": msg['src'],
	"type": "append_ok", "term": current_term}
	return_msg_json = json.dumps(return_msg)
	sock.send(return_msg_json.encode())

while True:
	for N in range(commit_index + 1, len(log)):
		num_matched = 0
		for the_id in replica_ids:
			if match_index[the_id] >= N:
				num_matched += 1
		if num_matched >= majority - 1 and log[N]["term"] == current_term:
			commit_index = N
	if applied_index >= no_op_index:
		leader_ready = True

	while commit_index > applied_index:
		applied_index += 1
		if log[applied_index]['client_ID'] != "no-op" and log[applied_index]["MID"]:
			the_key = ""
			for key in list(log[applied_index].keys()):
				if key != 'term' and key != 'client_ID' and key != 'MID':
					the_key = key
			val = log[applied_index][the_key]
			kvstore[the_key] = val
			return_msg = {"src": my_id, "dst": log[applied_index]['client_ID'],
			"leader": my_id, "type": "ok", "MID": log[applied_index]['MID']}
			if leader:
				# print("LEADER %s RESPONDING TO: %s" % (my_id, log[applied_index]["MID"]))
				return_msg_json = json.dumps(return_msg)
				sock.send(return_msg_json.encode())
			# messages["puts"][log[applied_index]["MID"]] = return_msg

	clock = time.time()
	second_clock = time.time()
	if leader:
		# code runs every 2 seconds
		if clock - last > 2:
			# send heartbeat
			send_heartbeat()
			last = clock
		if clock - append_clock > 1:
			send_append_entry("")
			append_clock = time.time()
		if catchup_state:
			if applied_index >= get_index:
				msg = cache[0][1]
				value = kvstore.get(msg['key'], "")
				return_msg = {"src": my_id, "dst": msg['src'],
				"leader": my_id, "type": "ok", "MID": msg['MID'], "value": value}
				return_msg_json = json.dumps(return_msg)
				sock.send(return_msg_json.encode())
				last_catchup = False
		if not leader_ready and commit_index >= no_op_index:
			catchup_state = True
			last_catchup = False
			first_append_entry = time.time()
			cache_len = len(cache)
			puts = False
			for i in range(cache_len):
				entry = cache.pop(0)
				msg = entry[1]
				if entry[0] == "put":
					if msg["MID"] not in messages["puts"]:
						puts = True
						log.append({msg["key"]: msg["value"], "term": current_term,
									"client_ID": msg['src'], "MID": msg['MID']})
						messages["puts"].append(msg["MID"])
				else:
					if msg["MID"] not in messages["gets"]:
						if puts:
							send_append_entry("")
							cache.insert(0, entry)
							messages["gets"].append(msg["MID"])
							break
						else:
							value = kvstore.get(msg['key'], "")
							return_msg = {"src": my_id, "dst": msg['src'],
							"leader": my_id, "type": "ok", "MID": msg['MID'], "value": value}
							return_msg_json = json.dumps(return_msg)
							sock.send(return_msg_json.encode())
						messages["gets"].append(msg["MID"])
			if not cache:
				send_append_entry("")
				leader_ready = True
				catchup_state = False

	# if have not received a heart beat... (empty list)
	# if not leader and second_clock - last_other > r:
	if not leader and second_clock - last_other > random.randint(4, 8):
		# if no heartbeats received.. then begin election timeout
		if len(past_beats) == 0:
			election_timeout = True
		else:
			past_beats = []
		last_other = second_clock
		r = random.randint(4, 8)

	if candidate and votes >= majority:
		#print(str(my_id) + " got enough votes")
		most_recent_leader = my_id
		leader = True
		candidate = False
		no_op_index = len(log)
		leader_ready = False
		# for the_id in replica_ids:
		# 	next_index[the_id] = log_len
		# 	match_index[the_id] = -1
		# if log_len == 0:
		# 	prev_term = 1
		# else:
		# 	prev_term = log[log_len - 1]['term']
		# for the_id in replica_ids:
		# 	entries = [{"key": "no-op", "value": "", "prev_index"}]
		# 	msg = {"src": my_id, "dst": the_id,
		# 		"leader": my_id, "type": "append_entry",
		# 		"key": "no-op", "value": "",
		# 		"term": current_term, "prev_index": log_len - 1,
		# 		"prev_term": prev_term, "lead_commit_index": commit_index,
		# 		"client_ID": "no-op", "MID": "no-op", "time": time.time()}

		# 	new_entry = {"key": the_key, "value": entry[the_key],
		# 	"prev_index": rep_next_index + i - 1, "prev_term": term,
		# 	"client_ID": entry['client_ID'], "MID": entry["MID"]}
		# msg = {"src": my_id, "dst": the_id, "leader": my_id, "term": current_term,
		# "type": "append_entry", "entries": entries, "lead_commit_index": commit_index}
		log.append({"no-op": "", "term": current_term, "client_ID": "no-op", "MID": "no-op"})
		send_append_entry("")

	ready = select.select([sock], [], [], 0.1)[0]
	if sock in ready:
		msg_raw = sock.recv(32768)
		if len(msg_raw) == 0:
			continue
		msg = json.loads(msg_raw)

		if leader:
			print(match_index)

		# if leader:
		# 	print(next_index)

		if leader and (msg['type'] == 'append_entry' or msg['type'] == 'bulk_append') and msg["term"] >= current_term:
			current_term = msg["term"]
			make_follower()
			print(my_id + " DEPOSED " + str(leader))

		# if you get a request vote, vote for them if you have not yet voted in this term
		if msg['type'] == "RequestVote" and not candidate:
			# if you haven't voted yet this term and they have greater or equal term
			if str(msg['term']) not in voting_hist and up_to_date(msg):
				print(my_id + "voted for " + msg["src"])
				return_msg = {"src": my_id, "dst": msg['src'],
							  "leader": "FFFF", "type": "vote"}
				election_timeout = False
				make_follower()
				return_msg_json = json.dumps(return_msg)
				sock.send(return_msg_json.encode())
				voting_hist[str(msg['term'])] = msg["src"]
				voted = True
			elif str(msg["term"]) in voting_hist and voting_hist[str(msg['term'])] == msg["src"]:
				return_msg = {"src": my_id, "dst": msg['src'],
				"leader": "FFFF", "type": "vote"}
				candidate = False
				election_timeout = False
				make_follower()
				return_msg_json = json.dumps(return_msg)
				sock.send(return_msg_json.encode())

		# follower committed
		if msg['type'] == 'append_ok':
			next_index[msg['src']] += 1
			match_index[msg['src']] = next_index[msg['src']] - 1
			# messages["appends"][msg["src"]] = [x for x in messages["appends"][msg["src"]] if x["MID"] != msg["MID"]]

		if msg['type'] == "append_fail":
			if msg["term"] > current_term:
				make_follower()
				continue
			if next_index[msg["src"]] > 0:
				next_index[msg['src']] -= 1
			match_index[msg["src"]] = -1
			
			#send_to_follower(msg["src"], msg)

		# append_entry from leader, append to own and send back OK
		if not leader and msg['type'] == 'append_entry':
			voted = False
			current_term = msg['term']
			most_recent_leader = msg['leader']
			candidate = False
			entries = msg["entries"]
			if not entries:
				past_beats.append(1)
				if msg['lead_commit_index'] > commit_index:
					commit_index = min(msg['lead_commit_index'], len(log) - 1)
					continue
			if msg['term'] < current_term:
				reply_false(msg)
				break
			for entry in entries:
				log_idx = len(log) - 1
				if entry['prev_index'] == -1:
					if log_idx == -1:
						log.append({entry['key']: entry['value'], "term": entry['term'],
						"client_ID": entry['client_ID'], "MID": entry['MID']})
						reply_true(msg)
					elif log[0]["term"] == entry["prev_term"]:
						reply_true(msg)
					else:
						reply_false(msg)
						break
				elif log_idx < entry['prev_index'] or \
						log[entry["prev_index"]]["term"] != entry['prev_term']:
					reply_false(msg)
					break
					#print("log index mismatched")
				elif log_idx == entry["prev_index"]:
					log.append({entry['key']: entry['value'], "term": entry['term'], 
					"client_ID": entry['client_ID'], "MID": entry['MID']})
					reply_true(msg)
				elif log_idx > entry['prev_index']:
					if log[entry['prev_index'] + 1]["term"] != entry['term']:
						log = log[0 : entry['prev_index'] + 1]
						log.append({entry['key']: entry['value'], "term": entry['term'], 
						"client_ID": entry['client_ID'], "MID": entry['MID']})
					reply_true(msg)

			if msg['lead_commit_index'] > commit_index:
				commit_index = min(msg['lead_commit_index'], len(log) - 1)

		# if you get a vote, keep track
		if msg['type'] == "vote" and candidate:
			votes += 1

		# if you get a put message
		elif msg['type'] == 'put':
			# redirect to leader
			if not leader:
				return_msg = {"src": my_id, "dst": msg['src'],
							  "leader": most_recent_leader, "type": "redirect",
							  "MID": msg['MID']}
				return_msg_json = json.dumps(return_msg)
				sock.send(return_msg_json.encode())
			# you are leader, append to own log and send out to replicas
			else:
				# if msg["MID"] in messages["puts"]:
				# 	sock.send(json.dumps(messages["puts"][msg["MID"]]).encode())
				# 	continue
				if not leader_ready:
					cache.append(("put", msg))
				else:
					if msg["MID"] not in messages["puts"]:
						# put into own log
						log.append({msg["key"]: msg["value"], "term": current_term,
									"client_ID": msg['src'], "MID": msg['MID']})
						# send out append entries
						send_append_entry("")
						messages["puts"].append(msg["MID"])

		# get message from client
		elif msg['type'] == 'get':
			# redirect to leader
			if not leader:
				return_msg = {"src": my_id, "dst": msg['src'],
							  "leader": most_recent_leader, "type": "redirect",
							  "MID": msg['MID']}
				return_msg_json = json.dumps(return_msg)
				sock.send(return_msg_json.encode())
			# if leader, get the value and send back
			else:
				# if msg["MID"] in messages["gets"]:
				# 	sock.send(json.dumps(messages["gets"][msg["MID"]]).encode())
				# 	continue
				if not leader_ready:
					cache.append(("get", msg))
				else:
					if msg["MID"] not in messages["gets"]:
						value = kvstore.get(msg['key'], "")
						if not value:
							return_msg = {"src": my_id, "dst": msg['src'],
									"leader": my_id, "type": "fail", "MID": msg['MID'], "value": value}
							continue
						return_msg = {"src": my_id, "dst": msg['src'],
									"leader": my_id, "type": "ok", "MID": msg['MID'], "value": value}
						return_msg_json = json.dumps(return_msg)
						sock.send(return_msg_json.encode())
						messages["gets"].append(msg["MID"])

	if candidate and time.time() - election_time > .5:
		print(my_id + " sending more votes")
		msg = {'src': my_id, 'dst': "FFFF", 'leader': "FFFF",
		'type': 'RequestVote', "term": current_term,
		"index": len(log) - 1, "prev_term": term}
		sock.send(json.dumps(msg).encode())
		election_time = time.time()

	if election_timeout and not voted:
		print(my_id + " starting election")
		# transition to candidate
		candidate = True
		# increment the current term
		current_term += 1
		# vote for yourself
		votes = 1
		# request votes from others
		election_time = time.time()
		if len(log) == 0:
			term = 1
		else:
			term = log[-1]['term']

		msg = {'src': my_id, 'dst': "FFFF", 'leader': "FFFF",
			   'type': 'RequestVote', "term": current_term,
			   "index": len(log) - 1,
					   "prev_term": term}
		sock.send(json.dumps(msg).encode())
		# print("requesting votes")
		election_timeout = False
